% !TeX root = index.tex
\iffalse
The Introduction brings readers from a general understanding of the topic 
to a point where they can begin to understand what it is you are intending to do. 

It starts with broad statements and ends with specific statements about your project. 
Along the way it introduces readers to what has been done in the literature and 
then tells them why your project results will be different.

The Introduction provides a motivation for the work and tells readers what you will be telling them.
The following sections may be written simply as paragraphs; 
nothing more is really needed in the Introduction. 
You do not have to separate out each section.
The Funnel model is a good way to organise the Introduction.

1) The funnel model begins with a general statement about the general topical area;
 for example, “Antennas have been used for communications for at least 100 years”.
 It then narrows the focus repeatedly with further sentences by introducing work that has been 
 done in the literature with the appropriate citations.
 Finally, it reaches your project. By that time the reader knows in general terms what your work
 is about and understands your motivations. 
 The number of cited works ranges from a few to very many. 
 But whatever the number, they are the most significant in the field and have made the most impact on the historical development of the topic.

2) Your specific Aims and Objectives follow. Use bullet points for each and spend a few sentences describing each.

3) Follow your Aims and Objectives with a specific literature review. 
 In section 1, the review was rather broad. Now is the time to focus in on several journal articles 
 or products or activities that most closely match your own project work. 
 Use a few sentences to describe each one and show specifically what was useful about them. 
 Show how your work would improve on their work. You need only a few here. 
 Use those that are most similar and most like your project.

End the Introduction with a one-line description of the contents of each following Chapter.For example, “Chapter 2 focuses on.... Chapter 3 describes the work.... In Chapter 4, an outline of the measuring equipment ..., etc.”
\fi

Since the 70s there has been a rise of many processor architectures that try to fulfil specific performance and power application constraints. One of more noticeable cases are ARM RISC architecture being used in mobile devices instead of the more popular and robust x86 CISC (Complex Instruction Set Computer) architecture in favour of simplicity, cost and lower power consumption \autocite{jamil_1995,blem_menon_sankaralingam_2013}. It has been shown that in low power applications, such as IoTs (Internet of Things), OISC implementation can be superior in power and data throughput comparing to traditional RISC architectures \autocite{yokota_saso_hara-azumi_2017, ahmed_sakamoto_anderson_hara-azumi_2015}. This project proposes to compare two novel RISC and OISC 8bit architectures and compare their performance, design complexity and efficiency.


\subsection{Aims and Objectives}

The project has three main objectives:
\begin{enumerate}
	\item Design and build a RISC based processor.
	\item Design and build an OISC based processor. 
	\item Design and perform a fair benchmark on both processors. 
\end{enumerate}

\subsection{Related Work}
\label{subsec:supporting_theory}
This section goes through supporting theory of RISC and OISC architectures, and their comparison.

The principal functions of general OISC architecture should have advantage in performance and power consumption while having lower transistor count. There are several theoretical models to implement a processor using only a one instruction, most important models are subtract and branch, MOVE and half-adder architectures \autocite{gilreath_laplante_2003}. 

Some researches have proven benefits of the subtract and branch architecture over the RISC:\\
$\bullet$ Using an OISC \texttt{SUBLEQ} (SUBtract and jump if Less or EQuial to zero) as a coprocessor for the MIPS-ISA processor to emulate the functionality of different classes shows desirable area/performance/power trade-offs \autocite{ahmed_sakamoto_anderson_hara-azumi_2015}.\\
$\bullet$ Comparing an OISC \texttt{SUBLEQ} multicore to a RISC achieves better performance and lower energy for streaming data processing \autocite{yokota_saso_hara-azumi_2017}.

Looking at the OISC \texttt{MOVE} type, it has been researched since early 90s. It has been shown that the OISC \texttt{MOVE} can benefit of a VLIW (very large instruction word) arrangement, classifying it as a SIMO (single instruction, multiple operation) or a SIMT (single instruction, multiple transports) architectures. The problem with all of these arrangements is that they exhibit poor or complex hardware utilization. OISC \texttt{MOVE} has been proposed as a design framework enabling a lower complexity, better hardware utilization, and a scalable performance \autocite{5348869}. In this framework a TTA is proposed which describes how a single instruction should transport the data. To support theoretical benefits, a \texttt{MOVE32INT} TTA has been designed \autocite{Corporaal94move32int} and proven to be superior architecture to the RISC. Using a 1.6$\mu m$ fabrication technology, RISC has achieved 20MHz clock with 20Mops/second, while \texttt{MOVE32INT} implemented using SoGs (Sea of Gates) achieved 80MHz with 320Mops/second \autocite{289981}.

The TTA framework as further used in other researches to implement ASIPs to solve various problems. Some relevant examples are RSA calculation \autocite{6128530}; matrix inversion \autocite{1540373}; Fast Fourier Transform (FFT) \autocite{8682289}; IWEP, RC4 and 3DES encryption \autocite{922340}; Parallel Finite Impulse Response (FIR) filter \autocite{1511285}; Low-Density Parity-Check (LDPC) encoding \autocite{6855236}; Software Defined Radio (SDR) \autocite{7363689}. One of the most recent researches use TTA architecture to solve Compressive Sensing algorithms. Research showed 9 times of energy efficiency to that of FPGA implemented NIOS II processor, and theoretical 20 time energy efficiency that of ARM Cortex-A15 \autocite{8573494}. In this particular research however, used ARM Cortex-A15 with 28nm Metal Gate CMOS technology, compares to TTA implemented on Altera Cyclone IV FPGA with 60nm Silicon Gate CMOS technology. Both processor implementations cannot be directly compared.

Most of these researches show that TTA has a greater power efficiency, a higher clock frequency and a lower logic resource count. 

These benefits come with an expense, VLIW has bigger instruction word, therefore a bigger program size. TTA especially suffers from this due to the redundant instructions. Some proposed solutions are variable length instructions and instruction templates, which reduced program size between 30\% and 44\% \autocite{1213033,6893206}; a compression based on arithmetic coding \autocite{4627144}; and a method to remove redundant instructions \autocite{5403730}. 
Software is another difficulty as the compiler need to take additional steps for the data transportation optimisations. TTA software can be easily exploited however, to embed a software pipelining and parallelism without need of the extra hardware \autocite{4595596}.

With the proposed \texttt{MOVE} framework, hardware utilisation shown to be improved by reducing transition activity \autocite{1207041}, reducing interconnects shown saving 13\% of energy \autocite{6972455} on an small scale. A novel architecture named SynZEN also showed a further improvements by using an adaptable processing unit and a simple control logic \autocite{6403142}.

\subsection{Project contents}
Section \ref{sec:objectives} will go more in details behind the motivation and project decisions based on \nameref{subsec:supporting_theory}. Section \ref{sec:theory} explains theory and result predictions. Section \ref{sec:methods} explains both processor design choices and how each processor part is implemented on OISC and RISC processor. It also includes assembler design and system setup. In section \ref{sec:results}, results will be discussed, including benchmark methods and future work. Summary and conclusion of design and results can be found in section \ref{sec:conclusion}. Appendix in section \ref{sec:appendix} includes any other information, such as both processor instruction set.
